m <- as.matrix(df)
rownames(m) <- paste("T", 1:nrow(m), sep="")
image(1:ncol(m), 1:nrow(m), t(m), col = terrain.colors(60), axes = FALSE)
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rownames(m))
View(df)
df <- read.csv("hm06.csv", header = TRUE)
m <- as.matrix(df)
rownames(m) <- paste("T", 1:nrow(m), sep="")
image(1:ncol(m), 1:nrow(m), t(m), col = terrain.colors(60), axes = FALSE)
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rownames(m))
collimit <- 20
df <- read.csv("hm06.csv", header = TRUE)
m <- as.matrix(df)
rownames(m) <- paste("T", 1:nrow(m), sep="")
image(1:collimit, 1:nrow(m), t(m), col = terrain.colors(60), axes = FALSE)
axis(1, 1:collimit, colnames(m))
axis(2, 1:nrow(m), rownames(m))
image(1:collimit, 1:nrow(m), t(m[,1:collimit]), col = terrain.colors(60), axes = FALSE)
axis(1, 1:collimit, colnames(m))
axis(2, 1:nrow(m), rownames(m))
df[1,1]
m <- as.matrix(df[,1:collimit])
rownames(m) <- paste("T", 1:nrow(m), sep="")
image(1:ncol(m), 1:nrow(m), t(m), col = terrain.colors(60), axes = FALSE)
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rownames(m))
collimit <- 20
df <- read.csv("hm06.csv", header = TRUE)
m <- as.matrix(df[,1:collimit])
rownames(m) <- paste("T", 1:nrow(m), sep="")
image(1:ncol(m), 1:nrow(m), t(m), col = terrain.colors(60), axes = FALSE)
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rownames(m))
m <- as.matrix(df[,])
rownames(m) <- paste("T", 1:nrow(m), sep="")
image(1:ncol(m), 1:nrow(m), t(m), col = terrain.colors(60), axes = FALSE)
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rownames(m))
collimit <- 20
df <- read.csv("hm06.csv", header = TRUE)
m <- as.matrix(df[,1:collimit])
rownames(m) <- paste("T", 1:nrow(m), sep="")
image(1:ncol(m), 1:nrow(m), t(m), col = terrain.colors(60), axes = FALSE)
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rownames(m))
m
m <- as.matrix(df)
rownames(m) <- paste("T", 1:nrow(m), sep="")
image(1:ncol(m), 1:nrow(m), t(m), col = terrain.colors(60), axes = FALSE)
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rownames(m))
df <- read.csv("hm06.csv", header = TRUE)
m <- as.matrix(df[,1:collimit])
rownames(m) <- paste("T", 1:nrow(m), sep="")
image(1:ncol(m), 1:nrow(m), t(m), col = terrain.colors(60), axes = FALSE)
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rownames(m))
df <- read.csv("hm06.csv", header = TRUE)
m <- as.matrix(df)
rownames(m) <- paste("T", 1:nrow(m), sep="")
image(1:ncol(m), 1:nrow(m), t(m), col = terrain.colors(60), axes = FALSE)
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rownames(m))
collimit <- 20
m <- as.matrix(df[,1:collimit])
rownames(m) <- paste("T", 1:nrow(m), sep="")
image(1:ncol(m), 1:nrow(m), t(m), col = terrain.colors(60), axes = FALSE)
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rownames(m))
collimit <- 100
m <- as.matrix(df[,1:collimit])
rownames(m) <- paste("T", 1:nrow(m), sep="")
image(1:ncol(m), 1:nrow(m), t(m), col = terrain.colors(60), axes = FALSE)
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rownames(m))
library("recommenderlab")
data(Jester5k)
Jester5k[1]
as.matrix(Jester5k[1]9
as.matrix(Jester5k[1])
as.matrix(Jester5k)[1]
Jester5k[1,1]
r_th <- Recommender(Jester5k[1:1000], method = "POPULAR")
r_hu <- Recommender(Jester5k[1:100], method = "POPULAR")
users < Jester5k[1001:1002]
pr_th <- predict(r_th, users, n=5)
pr_hu <- predict(r_hu, users, n=5)
users <- Jester5k[1001:1002]
pr_th <- predict(r_th, users, n=5)
pr_hu <- predict(r_hu, users, n=5)
pr_th <- as(predict(r_th, users, n=5), "list")
pr_hu <- as(predict(r_hu, users, n=5), "list")
pr_th
pr_hu
'> pr_th
$u20089
[1] "j89" "j72" "j47" "j93" "j76"
$u11691
[1] "j89" "j93" "j76" "j88" "j96"
> pr_hu
$u20089
[1] "j72" "j10" "j91" "j81" "j93"
$u11691
[1] "j88" "j91" "j81" "j93" "j89"
'
as(predict(r_th, users, type="ratings"), "matrix") # NA para los chistes ya valorados por cada usuario
as(predict(r_th, users, type="ratingMatrix"), "matrix") # Para los chistes ya valorados por cada usuario, aparece dicha valoraci贸n
as(Jester5k, "matrix")[1001:1002]
as(Jester5k, "matrix")[1001]
as(Jester5k, "matrix")[1001,]
as(Jester5k, "matrix")[1002,]
colnames(Jester5k)[1001]
names(Jester5k)[1001]
rownames(Jester5k)[1001]
rownames(Jester5k)[1002]
c(1:100, 1:1000)
list(1:100, 1:1000)
1:len(c(1.2))
1:len(c(1,2))
1:length(c(1,2))
labels <- list("hu", "th")
amounts <- list(1:100, 1:1000)
# Genera distintos esquemas de evaluaci贸n para cada divisi贸n de usuarios
e_schemas <- lapply(amounts, function(a) evaluationScheme(Jester5k[a], method="split", train=0.9, given=15, goodRating=5))
# Genera distintos recomendadores para cada esquema
rs <- lapply(e_schemas, function(es) Recommender(getData(es, "train"), method = "POPULAR"))
# Genera una predicci贸n para cada caso
ps <- lapply(1:length(labels), function(i) predict(rs[i], getData(e_schemas[i], "known"), type="ratings"))
rs
rs[[1]]
rs[1
]
ps <- lapply(1:length(labels), function(i) predict(rs[[i]], getData(e_schemas[[i]], "known"), type="ratings"))
ps
calcPredictionAccuracy(ps[[1]], getData(e_schemas[[1]], "unknown"))
errs <- lapply(1:length(amounts), function(i) calcPredictionAccuracy(ps[[i]], getData(e_schemas[[i]], "unknown")))
errs
as(errs, matrix)
as(errs, "matrix")
as(errs, "dataframe")
data.frame(errs)
unlist(errs)
data.frame(t(sapply(mylistlist,c)))
data.frame(t(sapply(errs,c)))
t(sapply(errs,c))
class(t(sapply(errs,c)))
table <- t(sapply(mylistlist,c))
rownames(table) <- labels
table <- data.frame(t(sapply(mylistlist,c)))
rownames(table) <- labels
table <- t(sapply(errs,c))
rownames(table) <- labels
table
library("recommenderlab")
data(Jester5k)
data(MovieLense)
df <- read.csv("hm06.csv", header = TRUE)
collimit <- 100
m <- as.matrix(df[,1:collimit])
rownames(m) <- paste("T", 1:nrow(m), sep="")
png("Plot3.png", width = 20000, height = 1000, units = 'px', res = 300)
image(1:ncol(m), 1:nrow(m), t(m), col = terrain.colors(60), axes = FALSE)
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rownames(m))
dev.off()
m <- as.matrix(df)
rownames(m) <- paste("T", 1:nrow(m), sep="")
png("Plot3.png", width = 20000, height = 1000, units = 'px', res = 300)
image(1:ncol(m), 1:nrow(m), t(m), col = terrain.colors(60), axes = FALSE)
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rownames(m))
dev.off()
ncol(m)
nrow(m)
png("Plot3.png", width = ncol(m), height = ncol(m)/nrow(m), units = 'px', res = 300)
image(1:ncol(m), 1:nrow(m), t(m), col = terrain.colors(60), axes = FALSE)
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rownames(m))
dev.off()
png("Plot3.png", width = 20000, height = 1000, units = 'px', res = 300); dev.off();
png("Plot3.png", width = 30000, height = 1000, units = 'px', res = 300); dev.off();
png("Plot3.png", width = 33000, height = 1000, units = 'px', res = 300); dev.off();
png("Plot3.png", width = 32768, height = 1000, units = 'px', res = 300); dev.off();
png("Plot3.png", width = 32767, height = 1000, units = 'px', res = 300); dev.off();
png("Plot3.png", width = 32000, height = 32000/nrow(m), units = 'px', res = 300)
image(1:ncol(m), 1:nrow(m), t(m), col = terrain.colors(60), axes = FALSE)
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rownames(m))
dev.off()
install.packages(c("colorspace", "digest", "ggplot2", "Rcpp"))
plot_last_row <- function(dataframe){
lastRow <- as.numeric(dataframe[nrow(dataframe),])
barplot(lastRow, names.arg = colnames(dataframe))
}
# Plots generic matrix as a image
# TODO: adjust legend size when exporting to big image
plot_matrix <- function(m){
num_distinct_values <- length(table(m)) # To know how many colours use in gradient
mi <- min(m, na.rm = TRUE)
ma <- max(m, na.rm = TRUE)
# Reverses rows to plot correctly
m_img <- apply(m, 2, rev)
colf <- colorRampPalette(c("red", "blue")) # Color gradient
layout(matrix(1:2,ncol=2), width = c(2,1),height = c(1,1)) # Two figures (image and legend)
image(1:ncol(m), 1:nrow(m), t(m_img), col = rev(colf(num_distinct_values)), axes = FALSE) # Plots image
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rev(rownames(m)))
legend_image <- as.raster(matrix(colf(num_distinct_values), ncol=1)) # Creates tegend
plot(c(0,2),c(0,1),type = 'n', axes = F,xlab = '', ylab = '', main = 'legend title') #Plots legend
text(x=1.5, y = seq(0,1,l=5), labels = seq(mi,ma,l=5)) # Adds labels to legend
rasterImage(legend_image, 0, 0, 1, 1)
}
# Makes all the process for a given dataframe: gets last row (used for number of accesses), conversion to matrix, plotting...
make_plot <- function(dataframe, filename = "", max_minus = NA, plots_last_row = FALSE){
rowsMinusLast <- 1:(nrow(dataframe)-1)
m <- t(data.matrix(dataframe[rowsMinusLast,])) # Convert to matrix without last row because it is used for number of accesses
# Turns (max - max_minus) values to NA if wanted
if(!is.na(max_minus)){
mx <- max(m, na.rm = "TRUE") # Gets maximum
cat("Max =", mx, "\n")
cat("Its position =", which(m == mx, arr.ind = TRUE), "\n")
filtr <- mx - max_minus
m[m < filtr] <- NA # Filters
}
# Saves image plot as png file if filename is not a empty string
if(filename != "")
png(filename, width = 32000, height = 32000/nrow(m), units = 'px', res = 300)
plot_matrix(m)
if(filename != "")
dev.off()
# Plots last row if wanted
if(plots_last_row)
plot_last_row(dataframe)
}
#node0_cpus <- seq(0,11,2) + 1
#node1_cpus <- seq(1,11,2) + 1
# Reads file
d <- read.csv("max_60.csv", header = TRUE, na.strings = "-1", row.name = 1)
View(d)
make_plot(d)
make_plot(d, "max_big.png")
make_plot(d, 5000)
make_plot(d, max_minus=5000)
make_plot(d, max_minus=10000)
dmin <- read.csv("min_60.csv", header = TRUE, na.strings = "-1", row.name = 1)
make_plot(dmin)
make_plot(d, max_minus=10000)
make_plot(d)
make_plot(dmin)
make_plot(d)
davg <- read.csv("avg_60.csv", header = TRUE, na.strings = "-1", row.name = 1)
dacc <- read.csv("acc_60.csv", header = TRUE, na.strings = "-1", row.name = 1)
dacs <- read.csv("acs_60.csv", header = TRUE, na.strings = "-1", row.name = 1)
dmax <- d
make_plot(davg)
make_plot(dacs)
make_plot(d, filename="max_10000_big.png",max_minus=10000)
make_plot(dmax, plots_last_row = TRUE)
file_suffixes <- c("acs", "avg", "min", "max")
d_filenames <- sapply(file_suffixes, function(s) paste("d_", s, ".csv", sep=""))
i_filenames <- sapply(file_suffixes, function(s) paste("i_", s, ".csv", sep=""))
#ds <- lapply(d_filenames, function(fn) read.csv(fn, header = TRUE, na.strings = "-1", row.name = 1))
is <- lapply(i_filenames, function(fn) read.csv(fn, header = TRUE, na.strings = "-1", row.name = 1))
ds <- lapply(d_filenames, function(fn) read.csv(fn, header = TRUE, na.strings = "-1", row.name = 1))
ds
names(ds)
ds[["acs"]]
make_plot(dacs)
make_plot(dacs, "acs_big.png")
make_plot(ds[["acs"]], "d_acs_big.png")
make_plot(is[["acs"]], "i_acs_big.png")
make_plot(is[["avg"]], "i_avg_big.png")
make_plot(ds[["avg"]], "d_avg_big.png")
make_plot(ds[["avg"]],  plots_last_row = TRUE)
ds <- lapply(d_filenames, function(fn) read.csv(fn, header = TRUE, na.strings = "-1", row.name = 1))
make_plot(ds[["acs"]], "d_acs_big.png")
make_plot(ds[["avg"]], "d_avg_big.png")
d <- read.csv("acs.csv", header = TRUE, na.strings = "-1", row.name = 1))
d <- read.csv("acs.csv", header = TRUE, na.strings = "-1", row.name = 1)
View(d)
barplot(d, names.arg = colnames(d))
d <- read.csv("acs.csv", header = TRUE, row.name = 1)
View(d)
barplot(d, names.arg = colnames(d))
barplot(d)
barplot(d, names.arg = colnames(d))
plot(rownames(d), d$threads_accessed, type="l")
plot(d$threads_accessed, xaxt = "n", xlab='Some Letters')
axis(1, at=d$threads_accessed, labels=rownames(d))
lot(d$threads_accessed, xaxt = "l", xlab='Some Letters')
axis(1, at=d$threads_accessed, labels=rownames(d))
plot(d$threads_accessed, xaxt = "l", xlab='Some Letters')
axis(1, at=d$threads_accessed, labels=rownames(d))
plot(d$threads_accessed, xaxt = "n", xlab='Some Letters')
axis(1, at=1:nrow(d), labels=rownames(d))
plot(d$threads_accessed, type="l", xaxt = "n", xlab='Some Letters')
axis(1, at=1:nrow(d), labels=rownames(d))
plot(d$threads_accessed, type="l", ylim=c(1, 4), xaxt = "n", xlab='Page Number')
axis(1, at=1:nrow(d), labels=rownames(d))
plot(d$threads_accessed, type="l", col = "r", xaxt = "n", xlab="Page Number", ylval="Number of threads that accessed")
axis(1, at=1:nrow(d), labels=rownames(d))
plot(d$threads_accessed, type="l", col = "r", xaxt = "n", xlab="Page Number", ylab="Number of threads that accessed")
axis(1, at=1:nrow(d), labels=rownames(d))
plot(d$threads_accessed, type="l", col = "r", xaxt = "n", xlab="Page Number", ylab="Number of threads that accessed")
axis(1, at=1:nrow(d), labels=rownames(d))
plot(d$threads_accessed, type="l", col = "red", xaxt = "n", xlab="Page Number", ylab="Number of threads that accessed")
axis(1, at=1:nrow(d), labels=rownames(d))
read_data_from_dir <- function(path) {
setwd(path)
# Files to be read
file_suffixes <- c("acs", "avg", "min", "max", "alt")
filenames <- sapply(file_suffixes, function(s) paste(s, ".csv", sep=""))
fs <- lapply(filenames, function(fn) read.csv(fn, header = TRUE, na.strings = "-1", row.name = 1))
return (fs)
}
# Bar plot for number of accesses
plot_last_row <- function(dataframe){
lastRow <- as.numeric(dataframe[nrow(dataframe),])
barplot(lastRow, names.arg = colnames(dataframe))
}
# Plots generic matrix as a image with log scale
# TODO: adjust legend size when exporting to big image
plot_matrix <- function(m){
mi <- min(m, na.rm = TRUE)
ma <- max(m, na.rm = TRUE)
max_exp <- ceiling(log10(ma-mi)) # Nearest exponent to maximum-minimum to scale better
exps <- 1:max_exp
vals <- c(mi, mi + 10**exps) # Minimum in scale is the minimum value instead of 0
num_vals <- length(vals)
# Reverses rows to plot correctly
m_img <- apply(m, 2, rev)
colf <- colorRampPalette(c("red", "blue")) # Color gradient
layout(matrix(1:2,ncol=2), width = c(2,1),height = c(1,1)) # Two figures (image and legend)
image(1:ncol(m), 1:nrow(m), t(m_img), col = rev(colf(num_vals -1L)), breaks = vals, axes = FALSE) # Plots image
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rev(rownames(m)))
legend_image <- as.raster(matrix(colf(num_vals), ncol=1)) # Creates legend
plot(c(0,2),c(0,1),type = 'n', axes = F,xlab = '', ylab = '', main = 'legend title') #Plots legend
text(x=1.5, y = seq(0,1,l=num_vals), labels = vals) # Adds labels to legend
rasterImage(legend_image, 0, 0, 1, 1)
}
# Makes all the process for a given dataframe: gets last row (used for number of accesses), conversion to matrix, plotting...
make_plot <- function(dataframe, filename = "", max_minus = NA, plots_last_row = FALSE){
rowsMinusLast <- 1:(nrow(dataframe)-1)
m <- t(data.matrix(dataframe[rowsMinusLast,])) # Convert to matrix without last row because it is used for number of accesses
# Turns (max - max_minus) values to NA if wanted
if(!is.na(max_minus)){
mx <- max(m, na.rm = "TRUE") # Gets maximum
cat("Max =", mx, "\n")
cat("Its position =", which(m == mx, arr.ind = TRUE), "\n")
filtr <- mx - max_minus
m[m < filtr] <- NA # Filters
}
# Saves image plot as png file if filename is not a empty string
if(filename != "")
png(filename, width = 32000, height = 32000/nrow(m), units = 'px', res = 300)
plot_matrix(m)
if(filename != "")
dev.off()
# Plots last row if wanted
if(plots_last_row)
plot_last_row(dataframe)
}
# For "alt" case
plot_alt <- function(df, filename = "") {
if(filename != "")
png(filename, width = 6000, height = 4000, units = 'px', res = 300)
# Plotting page number vs how many different threads accessed to it?
plot(df$threads_accessed, type="l", col = "red", xaxt = "n", xlab="Page Number", ylab="Number of threads that accessed")
axis(1, at=1:nrow(df), labels=rownames(df))
if(filename != "")
dev.off()
}
#node0_cpus <- seq(0,11,2) + 1
#node1_cpus <- seq(1,11,2) + 1
data <- read_data_from_dir("~/migrCPP")
make_plot(data[["avg"]])
data <- read_data_from_dir("~/migrCPP")
make_plot(data[["avg"]])
plot_matrix <- function(m){
mi <- min(m, na.rm = TRUE)
ma <- max(m, na.rm = TRUE)
max_exp <- ceiling(log10(ma-mi)) # Nearest exponent to maximum-minimum to scale better
exps <- 1:(max_exp-1)
vals <- c(mi, mi + 10**exps, ma) # Minimum in scale is the minimum value instead of 0
num_vals <- length(vals)
# Reverses rows to plot correctly
m_img <- apply(m, 2, rev)
colf <- colorRampPalette(c("red", "blue")) # Color gradient
layout(matrix(1:2,ncol=2), width = c(3,1),height = c(1,1)) # Two figures (image and legend)
image(1:ncol(m), 1:nrow(m), t(m_img), col = rev(colf(num_vals -1L)), breaks = vals, axes = FALSE) # Plots image
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rev(rownames(m)))
legend_image <- as.raster(matrix(colf(num_vals), ncol=1)) # Creates legend
plot(c(0,2),c(0,1),type = 'n', axes = F,xlab = '', ylab = '', main = 'legend title') #Plots legend
text(x=1.5, y = seq(0,1,l=num_vals), labels = vals) # Adds labels to legend
rasterImage(legend_image, 0, 0, 1, 1)
}
make_plot(data[["avg"]])
plot_matrix <- function(m){
mi <- min(m, na.rm = TRUE)
ma <- max(m, na.rm = TRUE)
max_exp <- floor(log10(ma-mi)) # Nearest flooring exponent to maximum-minimum to scale better
exps <- 1:max_exp
vals <- c(mi, mi + 10**exps, ma) # Min and max in scale are the absolute min and max values instead of 0 and big pow or 10 respectively
num_vals <- length(vals)
# Reverses rows to plot correctly
m_img <- apply(m, 2, rev)
colf <- colorRampPalette(c("red", "blue")) # Color gradient
layout(matrix(1:2,ncol=2), width = c(4,1),height = c(1,1)) # Two figures (image and legend)
image(1:ncol(m), 1:nrow(m), t(m_img), col = rev(colf(num_vals -1L)), breaks = vals, axes = FALSE) # Plots image
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rev(rownames(m)))
legend_image <- as.raster(matrix(colf(num_vals), ncol=1)) # Creates legend
plot(c(0,2),c(0,1),type = 'n', axes = F,xlab = '', ylab = '', main = 'legend title') #Plots legend
text(x=1.5, y = seq(0,1,l=num_vals), labels = vals) # Adds labels to legend
rasterImage(legend_image, 0, 0, 1, 1)
}
make_plot(data[["avg"]])
plot_matrix <- function(m){
mi <- min(m, na.rm = TRUE)
ma <- max(m, na.rm = TRUE)
max_exp <- floor(log10(ma-mi)) # Nearest flooring exponent to maximum-minimum to scale better
exps <- 1:max_exp
vals <- c(mi, mi + 10**exps, ma) # Min and max in scale are the absolute min and max values instead of 0 and big pow or 10 respectively
num_vals <- length(vals)
# Reverses rows to plot correctly
m_img <- apply(m, 2, rev)
colf <- colorRampPalette(c("red", "blue")) # Color gradient
layout(matrix(1:2,ncol=2), width = c(4,1),height = c(1,1)) # Two figures (image and legend)
image(1:ncol(m), 1:nrow(m), t(m_img), col = rev(colf(num_vals -1L)), breaks = vals, axes = FALSE) # Plots image
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rev(rownames(m)))
legend_image <- as.raster(matrix(colf(num_vals), ncol=1)) # Creates legend
plot(c(0,2),c(0,1),type = 'n', axes = F,xlab = '', ylab = '', main = "Aggregated latency value") #Plots legend
text(x=1.5, y = seq(0,1,l=num_vals), labels = vals) # Adds labels to legend
rasterImage(legend_image, 0, 0, 1, 1)
}
make_plot(data[["avg"]])
make_plot(data[["avg"]], "test.png")
plot_matrix <- function(m, big){
mi <- min(m, na.rm = TRUE)
ma <- max(m, na.rm = TRUE)
max_exp <- floor(log10(ma-mi)) # Nearest flooring exponent to maximum-minimum to scale better
exps <- 1:max_exp
vals <- c(mi, mi + 10**exps, ma) # Min and max in scale are the absolute min and max values instead of 0 and big pow or 10 respectively
num_vals <- length(vals)
# If the plot is going to be exported as a big image, the graphic will have a bigger width proportion of the image than the legend
image_prop <- 3
if(big)
image_prop <- 25
# Reverses rows to plot correctly
m_img <- apply(m, 2, rev)
colf <- colorRampPalette(c("red", "blue")) # Color gradient
layout(matrix(1:2,ncol=2), width = c(image_prop,1),height = c(1,1)) # Two figures (image and legend)
image(1:ncol(m), 1:nrow(m), t(m_img), col = rev(colf(num_vals -1L)), breaks = vals, axes = FALSE) # Plots image
axis(1, 1:ncol(m), colnames(m))
axis(2, 1:nrow(m), rev(rownames(m)))
legend_image <- as.raster(matrix(colf(num_vals), ncol=1)) # Creates legend
plot(c(0,2),c(0,1),type = 'n', axes = F,xlab = '', ylab = '', main = "Aggregated latency value") #Plots legend
text(x=1.5, y = seq(0,1,l=num_vals), labels = vals) # Adds labels to legend
rasterImage(legend_image, 0, 0, 1, 1)
}
# Makes all the process for a given dataframe: gets last row (used for number of accesses), conversion to matrix, plotting...
make_plot <- function(dataframe, filename = "", max_minus = NA, plots_last_row = FALSE){
rowsMinusLast <- 1:(nrow(dataframe)-1)
m <- t(data.matrix(dataframe[rowsMinusLast,])) # Convert to matrix without last row because it is used for number of accesses
# Turns (max - max_minus) values to NA if wanted
if(!is.na(max_minus)){
mx <- max(m, na.rm = "TRUE") # Gets maximum
cat("Max =", mx, "\n")
cat("Its position =", which(m == mx, arr.ind = TRUE), "\n")
filtr <- mx - max_minus
m[m < filtr] <- NA # Filters
}
# Saves image plot as png file if filename is not a empty string
if(filename != "")
png(filename, width = 32000, height = 32000/nrow(m), units = 'px', res = 300)
plot_matrix(m, TRUE)
dev.off()
} else
plot_matrix(m, FALSE)
# Plots last row if wanted
if(plots_last_row)
plot_last_row(dataframe)
}
make_plot <- function(dataframe, filename = "", max_minus = NA, plots_last_row = FALSE){
rowsMinusLast <- 1:(nrow(dataframe)-1)
m <- t(data.matrix(dataframe[rowsMinusLast,])) # Convert to matrix without last row because it is used for number of accesses
# Turns (max - max_minus) values to NA if wanted
if(!is.na(max_minus)){
mx <- max(m, na.rm = "TRUE") # Gets maximum
cat("Max =", mx, "\n")
cat("Its position =", which(m == mx, arr.ind = TRUE), "\n")
filtr <- mx - max_minus
m[m < filtr] <- NA # Filters
}
# Saves image plot as png file if filename is not a empty string
if(filename != "") {
png(filename, width = 32000, height = 32000/nrow(m), units = 'px', res = 300)
plot_matrix(m, TRUE)
dev.off()
} else
plot_matrix(m, FALSE)
# Plots last row if wanted
if(plots_last_row)
plot_last_row(dataframe)
}
make_plot(data[["avg"]])
make_plot(data[["avg"]], "test.png")
